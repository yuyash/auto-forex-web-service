name: Build and Deploy

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop

env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  BACKEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/forex-trading-backend
  FRONTEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/forex-trading-frontend

jobs:
  build-backend:
    name: Build Backend Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.BACKEND_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Backend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.BACKEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.BACKEND_IMAGE }}:buildcache,mode=max

  build-frontend:
    name: Build Frontend Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.FRONTEND_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Frontend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache,mode=max

  validate-docker-compose:
    name: Validate Docker Compose Configuration
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create dummy .env file for validation
        run: |
          cat > .env << EOF
          # Dummy values for validation only - DO NOT USE IN PRODUCTION

          # Database
          DB_NAME=forex_trading
          DB_USER=postgres
          DB_PASSWORD=dummy_password_for_validation
          DB_HOST=postgres
          DB_PORT=5432

          # Redis
          REDIS_PASSWORD=dummy_redis_password

          # Django
          SECRET_KEY=dummy-secret-key-for-validation-only-min-50-chars-long
          DEBUG=False
          ALLOWED_HOSTS=localhost,127.0.0.1

          # Security
          ENCRYPTION_KEY=dummy-encryption-key-32-chars-min

          # OANDA API
          OANDA_PRACTICE_API=https://api-fxpractice.oanda.com
          OANDA_LIVE_API=https://api-fxtrade.oanda.com

          # AWS (optional - empty values are fine for validation)
          AWS_ACCESS_KEY_ID=
          AWS_SECRET_ACCESS_KEY=
          AWS_S3_BUCKET=
          AWS_REGION=us-east-1
          EOF

      - name: Validate docker-compose.yaml
        run: |
          docker compose config > /dev/null
          echo "Docker Compose configuration is valid"

  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend, validate-docker-compose]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        env:
          SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p ${SSH_PORT} -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts 2>&1 || echo "StrictHostKeyChecking no" >> ~/.ssh/config

      - name: Deploy to production server
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          # Copy production docker-compose file
          scp -P ${SSH_PORT} docker-compose.prod.yaml ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_PATH}/docker-compose.yaml

          # Copy nginx configuration
          scp -P ${SSH_PORT} -r nginx ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_PATH}/

          # SSH into server and deploy
          ssh -p ${SSH_PORT} ${SERVER_USER}@${SERVER_HOST} << EOF
            cd ${DEPLOY_PATH}
            
            # Add DOCKERHUB_USERNAME to .env if not present
            if ! grep -q "DOCKERHUB_USERNAME" .env; then
              echo "DOCKERHUB_USERNAME=${DOCKERHUB_USERNAME}" >> .env
            fi
            
            # Pull latest images from DockerHub
            docker compose pull
            
            # Stop and remove old containers
            docker compose down
            
            # Start new containers
            docker compose up -d
            
            # Wait for PostgreSQL to be ready
            echo "Waiting for PostgreSQL to be healthy..."
            sleep 15
            
            # Sync PostgreSQL password with .env to prevent authentication issues
            DB_PASSWORD=\$(grep "^DB_PASSWORD=" .env | cut -d '=' -f2)
            if [ -n "\${DB_PASSWORD}" ]; then
              echo "Checking PostgreSQL password..."
              
              # Test if current password works
              if docker exec forex_postgres psql -U postgres -c "SELECT 1;" > /dev/null 2>&1; then
                echo "✓ PostgreSQL password is already correct, no restart needed"
              else
                echo "Updating PostgreSQL password to match .env..."
                docker exec forex_postgres psql -U postgres -c "ALTER USER postgres PASSWORD '\${DB_PASSWORD}';" 2>/dev/null || true
                echo "Password updated, restarting backend services..."
                docker compose restart backend celery celery-beat
                echo "✓ Password sync and restart completed"
              fi
            fi
            
            # Clean up old images
            docker image prune -af
            
            # Show running containers
            docker compose ps
          EOF

      - name: Verify deployment
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
        run: |
          ssh -p ${SSH_PORT} ${SERVER_USER}@${SERVER_HOST} << EOF
            cd ${DEPLOY_PATH}
            
            # Wait for services to be healthy
            sleep 10
            
            # Check if all services are running
            RUNNING_COUNT=\$(docker compose ps --status running --format json | wc -l)
            TOTAL_COUNT=\$(docker compose ps --format json | wc -l)
            
            echo "Running services: \${RUNNING_COUNT}/\${TOTAL_COUNT}"
            
            if [ "\${RUNNING_COUNT}" -eq "\${TOTAL_COUNT}" ] && [ "\${RUNNING_COUNT}" -gt 0 ]; then
              echo "✅ Deployment successful - all services are running"
              docker compose ps
              exit 0
            else
              echo "❌ Deployment failed - not all services are running"
              docker compose ps
              echo ""
              echo "Recent logs:"
              docker compose logs --tail=50
              exit 1
            fi
          EOF

      - name: Notify deployment status
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "✅ Deployment to production completed successfully"
          else
            echo "❌ Deployment to production failed"
          fi
