name: Build and Deploy

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop

env:
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  BACKEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/forex-trading-backend
  FRONTEND_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/forex-trading-frontend

jobs:
  build-backend:
    name: Build Backend Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.BACKEND_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Backend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.BACKEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.BACKEND_IMAGE }}:buildcache,mode=max

  build-frontend:
    name: Build Frontend Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.FRONTEND_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Frontend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache
          cache-to: type=registry,ref=${{ env.FRONTEND_IMAGE }}:buildcache,mode=max

  validate-docker-compose:
    name: Validate Docker Compose Configuration
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create dummy .env file for validation
        run: |
          cat > .env << EOF
          # Dummy values for validation only - DO NOT USE IN PRODUCTION

          # Database
          DB_NAME=forex_trading
          DB_USER=postgres
          DB_PASSWORD=dummy_password_for_validation
          DB_HOST=postgres
          DB_PORT=5432

          # Redis
          REDIS_PASSWORD=dummy_redis_password

          # Django
          SECRET_KEY=dummy-secret-key-for-validation-only-min-50-chars-long
          DEBUG=False
          ALLOWED_HOSTS=localhost,127.0.0.1

          # Security
          ENCRYPTION_KEY=dummy-encryption-key-32-chars-min

          # OANDA API
          OANDA_PRACTICE_API=https://api-fxpractice.oanda.com
          OANDA_LIVE_API=https://api-fxtrade.oanda.com

          # AWS (optional - empty values are fine for validation)
          AWS_ACCESS_KEY_ID=
          AWS_SECRET_ACCESS_KEY=
          AWS_S3_BUCKET=
          AWS_REGION=us-east-1
          EOF

      - name: Validate docker-compose.yaml
        run: |
          docker compose config > /dev/null
          echo "Docker Compose configuration is valid"

  deploy:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend, validate-docker-compose]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        env:
          SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p ${SSH_PORT} -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts 2>&1 || echo "StrictHostKeyChecking no" >> ~/.ssh/config

      - name: Deploy to production server
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          # Copy production docker-compose file
          scp -P ${SSH_PORT} docker-compose.prod.yaml ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_PATH}/docker-compose.yaml

          # Copy nginx configuration
          scp -P ${SSH_PORT} -r nginx ${SERVER_USER}@${SERVER_HOST}:${DEPLOY_PATH}/

          # SSH into server and deploy
          ssh -p ${SSH_PORT} ${SERVER_USER}@${SERVER_HOST} << EOF
            cd ${DEPLOY_PATH}
            
            # Add DOCKERHUB_USERNAME to .env if not present
            if ! grep -q "DOCKERHUB_USERNAME" .env; then
              echo "DOCKERHUB_USERNAME=${DOCKERHUB_USERNAME}" >> .env
            fi
            
            # Pull latest images from DockerHub
            docker compose pull
            
            # Stop and remove old containers
            docker compose down
            
            # Start new containers
            docker compose up -d
            
            # Clean up old images
            docker image prune -af
            
            # Show running containers
            docker compose ps
          EOF

      - name: Verify deployment
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          SSH_PORT: ${{ secrets.SSH_PORT || '22' }}
        run: |
          ssh -p ${SSH_PORT} ${SERVER_USER}@${SERVER_HOST} << 'EOF'
            cd ${DEPLOY_PATH}
            
            # Wait for services to be healthy
            sleep 10
            
            # Check if all services are running
            if docker compose ps | grep -q "Up"; then
              echo "Deployment successful - services are running"
              exit 0
            else
              echo "Deployment failed - services are not running"
              docker compose logs --tail=50
              exit 1
            fi
          EOF

      - name: Notify deployment status
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "✅ Deployment to production completed successfully"
          else
            echo "❌ Deployment to production failed"
          fi
