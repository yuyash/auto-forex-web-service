"""
Strategy Executor for running trading strategies on tick data.

This module provides the StrategyExecutor class that processes tick updates,
calls strategy.on_tick(), generates orders from strategy signals, and updates
strategy state.

Requirements: 5.3
"""

import logging
import uuid
from typing import Any

from django.db import transaction

from .base_strategy import BaseStrategy
from .models import Order, Strategy
from .strategy_registry import registry
from .tick_data_models import TickData

logger = logging.getLogger(__name__)


class StrategyExecutor:
    """
    Executor for running trading strategies on tick data.

    This class manages the execution of trading strategies by processing
    incoming tick data, calling the strategy's on_tick method, and handling
    the resulting order signals.

    Requirements: 5.3
    """

    def __init__(self, strategy: Strategy) -> None:
        """
        Initialize the strategy executor.

        Args:
            strategy: Strategy model instance to execute

        Raises:
            ValueError: If strategy type is not registered
        """
        self.strategy_model = strategy
        self.account = strategy.account

        # Get strategy class from registry
        try:
            strategy_class = registry.get_strategy_class(strategy.strategy_type)
        except KeyError as exc:
            raise ValueError(f"Strategy type '{strategy.strategy_type}' is not registered") from exc

        # Instantiate strategy
        self.strategy_instance: BaseStrategy = strategy_class(strategy)

        logger.info(
            "StrategyExecutor initialized for strategy %s (type: %s, account: %s)",
            strategy.id,
            strategy.strategy_type,
            self.account.account_id,
        )

    def process_tick(self, tick_data: TickData) -> list[Order]:
        """
        Process a tick update and execute strategy logic.

        This method:
        1. Validates the tick data
        2. Calls strategy.on_tick() to get order signals
        3. Generates orders from the signals
        4. Updates strategy state
        5. Logs the execution

        Args:
            tick_data: TickData instance containing market data

        Returns:
            List of Order instances generated by the strategy

        Requirements: 5.3
        """
        # Validate tick data
        if not self._validate_tick(tick_data):
            logger.warning(
                "Invalid tick data for instrument %s, skipping",
                tick_data.instrument,
            )
            return []

        # Check if strategy is active
        if not self.strategy_model.is_active:
            logger.debug(
                "Strategy %s is not active, skipping tick processing",
                self.strategy_model.id,
            )
            return []

        # Check if instrument is in strategy's instruments list
        if not self.strategy_instance.is_instrument_active(tick_data.instrument):
            logger.debug(
                "Instrument %s not active for strategy %s, skipping",
                tick_data.instrument,
                self.strategy_model.id,
            )
            return []

        try:
            # Call strategy's on_tick method
            logger.debug(
                "Processing tick for %s at %s (bid: %s, ask: %s)",
                tick_data.instrument,
                tick_data.timestamp,
                tick_data.bid,
                tick_data.ask,
            )

            order_signals = self.strategy_instance.on_tick(tick_data)

            # Generate orders from signals
            orders = self._generate_orders(order_signals)

            # Update strategy state
            self._update_strategy_state(tick_data)

            # Log execution
            self._log_execution(tick_data, len(orders))

            return orders

        except Exception as exc:  # pylint: disable=broad-except
            logger.exception(
                "Error processing tick for strategy %s: %s",
                self.strategy_model.id,
                exc,
            )
            self._log_error(tick_data, str(exc))
            return []

    def _validate_tick(self, tick_data: TickData) -> bool:
        """
        Validate tick data.

        Args:
            tick_data: TickData instance to validate

        Returns:
            True if tick data is valid, False otherwise
        """
        if tick_data.bid is None or tick_data.ask is None:
            return False

        if tick_data.bid <= 0 or tick_data.ask <= 0:
            return False

        if tick_data.bid >= tick_data.ask:
            return False

        return True

    def _generate_orders(self, order_signals: list[Order]) -> list[Order]:
        """
        Generate and save orders from strategy signals.

        Args:
            order_signals: List of Order instances from strategy

        Returns:
            List of saved Order instances
        """
        if not order_signals:
            return []

        saved_orders = []

        with transaction.atomic():
            for order in order_signals:
                # Ensure order has required fields
                order.account = self.account
                order.strategy = self.strategy_model

                # Generate unique order ID if not set
                if not order.order_id:
                    order.order_id = self._generate_order_id()

                # Set default status if not set
                if not order.status:
                    order.status = "pending"

                # Save order
                order.save()
                saved_orders.append(order)

                logger.info(
                    "Generated order %s: %s %s %s units of %s",
                    order.order_id,
                    order.order_type,
                    order.direction,
                    order.units,
                    order.instrument,
                )

        return saved_orders

    def _generate_order_id(self) -> str:
        """
        Generate a unique order ID.

        Returns:
            Unique order ID string
        """
        return f"ORD-{uuid.uuid4().hex[:12].upper()}"

    def _update_strategy_state(self, tick_data: TickData) -> None:
        """
        Update strategy state after processing tick.

        Args:
            tick_data: TickData instance that was processed
        """
        try:
            # Update last tick time in strategy state
            state_updates = {
                "last_tick_time": tick_data.timestamp,
            }

            self.strategy_instance.update_strategy_state(state_updates)

            logger.debug(
                "Updated strategy state for strategy %s",
                self.strategy_model.id,
            )

        except Exception as exc:  # pylint: disable=broad-except
            logger.exception(
                "Error updating strategy state for strategy %s: %s",
                self.strategy_model.id,
                exc,
            )

    def _log_execution(self, tick_data: TickData, order_count: int) -> None:
        """
        Log strategy execution.

        Args:
            tick_data: TickData instance that was processed
            order_count: Number of orders generated
        """
        details: dict[str, Any] = {
            "instrument": tick_data.instrument,
            "timestamp": tick_data.timestamp.isoformat(),
            "bid": str(tick_data.bid),
            "ask": str(tick_data.ask),
            "mid": str(tick_data.mid),
            "orders_generated": order_count,
        }

        description = (
            f"Processed tick for {tick_data.instrument}, " f"generated {order_count} orders"
        )
        self.strategy_instance.log_strategy_event(
            event_type="tick_processed",
            description=description,
            details=details,
        )

    def _log_error(self, tick_data: TickData, error_message: str) -> None:
        """
        Log strategy execution error.

        Args:
            tick_data: TickData instance that was being processed
            error_message: Error message
        """
        details: dict[str, Any] = {
            "instrument": tick_data.instrument,
            "timestamp": tick_data.timestamp.isoformat(),
            "error": error_message,
        }

        self.strategy_instance.log_strategy_event(
            event_type="tick_processing_error",
            description=f"Error processing tick for {tick_data.instrument}: {error_message}",
            details=details,
        )

    def stop(self) -> None:
        """
        Stop the strategy executor.

        This method stops the strategy and performs cleanup.
        """
        logger.info(
            "Stopping strategy executor for strategy %s",
            self.strategy_model.id,
        )

        # Stop the strategy
        self.strategy_model.stop()

        logger.info(
            "Strategy executor stopped for strategy %s",
            self.strategy_model.id,
        )

    def get_status(self) -> dict[str, Any]:
        """
        Get current status of the strategy executor.

        Returns:
            Dictionary containing status information
        """
        return {
            "strategy_id": self.strategy_model.id,
            "strategy_type": self.strategy_model.strategy_type,
            "account_id": self.account.account_id,
            "is_active": self.strategy_model.is_active,
            "instruments": self.strategy_model.instruments,
            "started_at": (
                self.strategy_model.started_at.isoformat()
                if self.strategy_model.started_at
                else None
            ),
            "state": self.strategy_instance.get_strategy_state(),
        }

    def __repr__(self) -> str:
        """Developer-friendly representation of the executor."""
        return (
            f"<StrategyExecutor strategy_id={self.strategy_model.id} "
            f"type={self.strategy_model.strategy_type} "
            f"account={self.account.account_id} "
            f"active={self.strategy_model.is_active}>"
        )
